#+TITLE:Cakelisp

[[file:images/CakeLisp_gradient_128.png]]

This is a Lisp-like language where I [[https://en.wikipedia.org/wiki/You_can%27t_have_your_cake_and_eat_it][can have my cake and eat it (too)]]. I wanted to do this after my [[https://macoy.me/code/macoy/LanguageTests][LanguageTests]] experiment revealed just how wacky Common Lisp implementations are in regards to performance.

The end goal is a metaprogrammable, hot-reloadable, non-garbage-collected language ideal for high performance, iteratively-developed programs.

* Desired features
- The metaprogramming capabilities of Lisp
- The performance of C
- "Real" types: Types are identical to C types, e.g. ~int~ is 32 bits with no sign bit or anything like other Lisp implementations do
- No garbage collection: I can handle my own memory
- Hot reloading: It should be possible to make modifications to functions *and structures* at runtime to quickly iterate
- Truly seamless C and C++ interoperability: No bindings, no wrappers: C/C++ types and functions are as easy to declare and call as they are in C/C++. In order to support this, I've decided to ignore type deduction when possible and instead rely on the C compiler/linker to relay typing errors. Cakelisp will blindly generate what look like C/C++ function calls without knowing if that function actually exists, because the C/C++ compiler will tell us what the answer is
- Output is human-readable C/C++ source and header files. This is so if I decide it was unsuccessful, or only useful in some scenarios (e.g. generating serialization wrappers), I can still use the output code from hand-written C/C++ code
* Plan
- Tokenize and evaluator written in C++
- Export evaluated output to C/C++
- Compile generated C/C++

Cakelisp itself is extended via "generators", which are functions which take Cakelisp tokens and output C/C++ source code. Because generators are written in C++, generators can also be written in Cakelisp! Cakelisp will compile the generators in a module into a dynamic library, then load that library before continuing parsing the module.

Macros are similar to generators, only they output Cakelisp tokens instead of C/C++ code. Macro definitions also get compiled to C/C++, using the same generators which compile regular Cakelisp functions.

This means the only thing the evaluator meaningfully does is call C/C++ functions based on the original or macro-generated Cakelisp tokens.
** Detailed function
1. Tokenize ~.cake~ file into Token array
2. Iterate through token array, looking for generator definitions
3. If there are generator definitions, generate code for those definitions, compile it, load it via dynamic linking, then add it to the environment's generator table. Base-level generators will need to be written in C++ to bootstrap the language
4. Iterate through token array, looking for generator invocations
5. Run generator as requested by invocation
6. Return to step 2 in case generators created generators
7. Once no generators are invoked, output the generator operations
8. From generator operations, create C/C++ header and source files, as well as line mapping files. Mapping files will record C source location to Cakelisp source location pairs, so debuggers, C compiler errors etc. all map back to the Cakelisp that caused that line
9. Compile generated C/C++ files. If there are warnings or errors, use the mapping file to associate them back to the original Cakelisp lines that caused that code to be output

* Compared to C-mera
The most similar thing to Cakelisp is [[https://github.com/kiselgra/c-mera][C-mera]]. I was not aware of it until after I got a good ways into the project. I will be forging ahead with my own version, which has the following features C-mera lacks (to my limited knowledge):
- Automatic header file generation
- Powerful mapping file for debugging, error reporting, etc. on the source code, not just the generated code
- Intended to support more than "just" code generation, e.g. code to support hot-reloading and runtime type information will be created
- I will likely add some global environment that will be modifiable by any modules in the project. This is useful for things like automatic "command" function generation with project-wide scope

Features C-mera has that Cakelisp doesn't:
- Access to Common Lisp macros, which is a huge swath of useful code generators
- Support for generating other languages. At this point, the C/C++ output is hardcoded, and would be a bit painful to change
- Multiple contributors and years of refinement
- It's done, and has proven itself useful
- Almost definitely has a cleaner implementation
** Implementation language pros and cons
Cakelisp is written in C/C++ while C-mera is written in Common Lisp. 

This is good and bad: the advanages of writing it in C/C++ are:
- It is fast; no garbage collection pauses etc. to deal with. This might not actually be the case if intermediate compilation and loading of generators and macros ends up being slow
- C++ is what I'm most familiar with; it would've taken me much longer in Common Lisp simply because I'm inexperienced in it
- Cakelisp does not depend on a runtime, which means it would be possible to integrate the Cakelisp compiler into the project being compiled itself. This could be pretty handy for in-process self-modification thanks to the hot-reloading features
- Macros and generators can be written in the same language being generated (and in Cakelisp, of course, because Cakelisp itself can load its own generated code to expand itself)

The bad things:
- There's no macro-writing library to draw from (macros which help write macros)
- Like previously mentioned, macros and generators need to be converted to C/C++ and compiled by an external compiler to be executed, whereas Common Lisp would make this whole process much easier by natively supporting macro code generation and evaluation

* (Somewhat) Similar languages
- [[http://www.call-cc.org/][Chicken scheme]]: Transpiles to C. This one seemed the "best" of the competitors, because it's fairly active still. Has heavyweight C function bindings, GC
- [[https://common-lisp.net/project/ecl/static/manual/index.html#Top][ECL]]: embeddable common lisp
- [[https://ferret-lang.org/][Ferret]]: Lisp compiled down to C++

The following I believe have little or no activity, implying they are no longer supported:
- [[https://github.com/tomhrr/dale][Dale]]: "Lisp-flavoured C". Hasn't been touched in over two years. It is similar to what I'm going for, I think
- [[https://github.com/wolfgangj/bone-lisp][Bone Lisp]]: Lisp with no GC. Creator has abandoned it, but it still gets some attention
- [[https://github.com/carp-lang/Carp][Carp]]: Performance-oriented. see [[https://github.com/carp-lang/Carp/blob/master/docs/LanguageGuide.md][Language guide]]
- [[https://github.com/ska80/thinlisp][Thinlisp]]: No GC option available. Write your stuff in CL using the cushy SBCL environment, then compile down to C for good performance
* Tooling support
** Emacs
Open ~.cake~ files in ~lisp-mode~:
#+BEGIN_SRC lisp
(add-to-list 'auto-mode-alist '("\\.cake?\\'" . lisp-mode))
#+END_SRC
** Build systems
A build system will work fine with Cakelisp as long as it meets these criteria:
- C/C++ includes from Cakelisp can be detected, to determine dependencies the ~.cake~ file has

See ~test/BuildWithJam/Jamrules~ for an example using the [[https://www.perforce.com/documentation/jam-documentation][Jam]] build tool.
