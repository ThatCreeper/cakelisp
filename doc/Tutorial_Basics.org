#+title: Cakelisp tutorial: basics

* Prerequisites
- Experience writing C or C++ programs. If you're just learning how to program, you should a different language rather than Cakelisp for now.

* Setup
First, [[https://github.com/makuto/cakelisp/archive/refs/heads/master.zip][download Cakelisp]]. You can also clone it through git. The URL is [[https://github.com/makuto/cakelisp]].

Unzip the ~master.zip~ file, if you downloaded it manually.

* Cakelisp's repository
The following section may be skipped. It serves as a quick introduction to the collection of files you downloaded.

Cakelisp consists of the following major components:

** A collection of C++ files
The core of Cakelisp itself is in the ~src/~ directory.

These files define the functionality of Cakelisp:

- Tokenizer: Turns ~.cake~ text files into arrays of tokens, which is easier to work with
- Evaluator: Uses the arrays of tokens as instructions on how to manipulate the "Environment"
- Generators: Invoked by the evaluator, generators create C/C++ text output
- Writer: Writes generated outputs to C/C++-language text files
- Module manager: Handles the separation of files into modules and performs the high-level procedure
- Build system: Invokes the compiler, linker, and dynamic loader as necessary to build your program

You don't need to know exactly what these do for now.

** Runtime
The ~runtime/~ directory stores ~.cake~ files which provide various features:

- ~CHelpers.cake~ provide various helper macros and generators for writing C/C++ code
- ~CppHelpers.cake~ provide C++-only features
- ~Cakelisp.cake~ makes it possible to run cakelisp while within another cakelisp compile-time phase

...and more. With the C/CPP helpers files, they have any language feature that wasn't essential to include in ~Generators.cpp~ as "built-ins".

Nothing in ~runtime/~ will actually affect your program unless you explicitly ~import~ them.

** Supplementary things
- ~doc/~ folder contains Cakelisp documentation
- ~tools/~ holds 3rd-party configuration files for making other tools work with Cakelisp
- ~test/~ consists of several ~.cake~ files used to test the language while it is developed

* Preparing your environment
Cakelisp relies on a C++ compiler and linker to perform various things. Your system needs to have a C++ toolchain set up.

- On Windows, download and install [[https://visualstudio.microsoft.com/downloads/][Visual Studio]] for best results
- On Linux, your system should already have ~g++~ or ~clang++~ installed
- On Mac, you need ~clang++~

Once these prerequisites are satisfied, do the following:

- Windows: Run ~Build.bat~
- Linux: Run ~Build.sh~
- Mac: (TODO) Run ~Build_Mac.sh~

If the script fails, please email ~macoy@macoy.me~ so I can help you and make this build step more robust.

If they succeed, you now have a working ~cakelisp~ binary in the ~bin/~ directory!

** A note on installs
The language is changing fast enough that I recommend against doing a system-wide installation of ~cakelisp~. If you are using version control, you should check in the entirety of Cakelisp as a submodule so that you always have the compatible version for that project.

* First program

Let's make sure everything is working. Create a new file ~Hello.cake~ and edit it to have the following:

#+BEGIN_SRC lisp
  (c-import "<stdio.h>")

  (defun main (&return int)
    (fprintf stderr "Hello, Cakelisp!\n")
    (return 0))
#+END_SRC

If you're familiar with C (which you probably should be; I will basically assume you are in this tutorial), this should be pretty simple.

We're just getting started though; this language is much more than C with more parentheses.

Build the file with the following command (adjust to make it ~cakelisp.exe~ on Windows, if necessary):

#+BEGIN_SRC sh
  ./bin/cakelisp --execute Hello.cake
#+END_SRC

If everything is set up properly, you should see:

#+BEGIN_SRC output
  Successfully built and linked a.out
  Hello, Cakelisp!
#+END_SRC

You can see that it not only built, but ran the output executable for us, thanks to that ~--execute~ option.

If you run that same command again, you'll see slightly different output:

#+BEGIN_SRC output
  No changes needed for a.out
  Hello, Cakelisp!
#+END_SRC

Cakelisp's build system automatically caches build artifacts and only rebuilds things when you make changes.

* Special sauce

"Hello World" is pretty boring. Let's write a program that would be difficult to write in a language without Cakelisp's features.

Let's write a program which takes the name of a command and executes it, much like ~git~ does (e.g. ~git add~ or ~git commit~, where ~add~ and ~commit~ are commands).

However, to show off Cakelisp, we're going to have the following rule:

/Adding a command should be as easy as writing a function./

This means no boilerplate is allowed.

** Taking user input
Modify our ~main~ function to take command-line arguments:

#+BEGIN_SRC lisp
  (defun main (num-arguments int
               arguments ([] (* char))
               &return int)
    (unless (= 2 num-arguments)
      (fprintf stderr "Expected command argument\n")
      (return 1))
    (fprintf stderr "Hello, Cakelisp!\n")
    (return 0))
#+END_SRC

By convention, names are written in Kebab style, e.g. ~num-arguments~ rather than ~numArguments~ or ~num_arguments~. This is purely up to you to follow or ignore, however.

Now, if we build, we should see the following:

#+BEGIN_SRC sh
  Successfully built and linked a.out
  Expected command argument
  /home/macoy/Repositories/cakelisp/a.out
  error: execution of a.out returned non-zero exit code 256
#+END_SRC

You can see that Cakelisp ~--execute~ output additional info because we returned a non-zero exit code. This is useful if you are using ~--execute~ in a process chain to run Cakelisp code just like a script.

*TODO*: Currently, Cakelisp ~--execute~ has no way to forward arguments to your output executable. From now on, remove the ~--execute~ and run it like so, adjusting accordingly for your platform (e.g. ~output.exe~ instead of ~a.out~):

#+BEGIN_SRC sh
  ./bin/cakelisp Hello.cake && ./a.out MyArgument
#+END_SRC

Doing the build on the same command as your execution will make sure that you don't forget to build after making changes.

You should now see:

#+BEGIN_SRC sh
  Hello, Cakelisp!
#+END_SRC

** Creating commands
In order to associate a function with a string input by the user, we need a lookup table. The table will have a string as a key and a function pointer as a value.

However, we need to follow our rule that no human should have to write boilerplate like this, because that would make it more difficult than writing a function.

We will accomplish this by creating a /macro/. Macros in Cakelisp let you execute arbitrary code at compile time and generate new tokens for the evaluator to evaluate.

These are unlike C macros, which only do string pasting.

Let's write our first macro:

#+BEGIN_SRC lisp
  (defmacro hello-from-macro ()
    (tokenize-push output
      (fprintf stderr "Hello from macro land!\n"))
    (return true))
#+END_SRC

~tokenize-push~ is a generator where the first argument is a token array to output to, and the rest are tokens to output.

We will learn more about it as we go through this tutorial.

Every macro can decide whether it succeeded or failed, which is why we ~(return true)~ to finish the macro. This gives you the chance to perform input validation, which isn't possible in C macros.

Invoke the macro in ~main~:

#+BEGIN_SRC lisp
  (defun main (num-arguments int
               arguments ([] (* char))
               &return int)
    (unless (= 2 num-arguments)
      (fprintf stderr "Expected command argument\n")
      (return 1))
    (fprintf stderr "Hello, Cakelisp!\n")
    (hello-from-macro)
    (return 0))
#+END_SRC

And observe that /"Hello from macro land!"/ is now output.
