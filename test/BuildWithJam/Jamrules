##
## Compilation
##

C++ = clang++ ;
LINK = clang++ ;
# C++ = g++ ;
# LINK = g++ ;

CAKELISP = ../../cakelisp ;

# If I was building a library, these would be useful
# LINKFLAGS = -shared ;
# if $(UNIX)      { SUFSHR = .so ; }
# else if $(NT)   { SUFSHR = .dll ; }

## Compiler arguments

if $(UNIX)
{
  OS_DEPENDENT_C++FLAGS = -DUNIX ;
  # For dynamic linking
  OS_DEPENDENT_LINKFLAGS = -ldl ;
}
else if $(NT)
{
  OS_DEPENDENT_C++FLAGS = -DWINDOWS ;
  # TODO: Windows support
  OS_DEPENDENT_LINKFLAGS = ;
}

# Arguments used on all projects, regardless of any variables
C++FLAGS = -std=c++11 -Wall -Wextra -Wno-unused-parameter
# Only for profiling, i.e. not release builds
# -DTRACY_ENABLE
# BT_USE_DOUBLE_PRECISION solves the Dantzig LCP missing definition
# Disabled now that I'm compiling Bullet in single-precision
# -DBT_USE_DOUBLE_PRECISION
-g
# Needed for dynamic linking
-fPIC

$(OS_DEPENDENT_C++FLAGS)
;

# HDRS = src
# # Dependencies/base2.0
# # Dependencies/glm
# # Dependencies/tracy
# Dependencies/curl/include
# Dependencies/rapidjson/include
# Dependencies/mecab/build/local/include
# Dependencies/parallel-hashmap/parallel_hashmap
# ;

# TODO: Make base hold all this weirdness?
# if $(DEBUG_BUILD)
# {
#   SFML_LINKLIBS = -lsfml-audio-d -lsfml-graphics-d -lsfml-window-d -lsfml-system-d ;
# }
# else
# {
#   SFML_LINKLIBS = -lsfml-audio -lsfml-graphics -lsfml-window -lsfml-system ;
# }

OPTIM = -O0 ;

##
## Linking
##

LINKLIBS =
# Standard (e.g. for Tracy)
-lpthread
# Functions for dynamically loading libraries (UNIX)
-ldl
;

# LINKFLAGS = -Wl,-rpath,. ;

LINKFLAGS = -g
# -Wl = pass to linker
# --export-dynamic = 
-Wl,-rpath,.,--export-dynamic
;
# TODO: Copy libs to better directory, or static link?
# -Wl,-rpath,.:Dependencies/curl/local_install/lib:Dependencies/mecab/build/local/lib ;

##
## Jam stuff
##

# Fix for unnecessary rebuilding any Jam project
KEEPOBJS = true ; # This doesn't actually fix anything, though it seems like it should
NOARSCAN = true ; # This actually fixes the problem
#AR = ar rUu ; # I was thinking maybe the AR command was wrong (always outputting deterministically)
               # It doesn't seem like this is the problem though
AR = ar cr ;

# Cross compilation
# E.g.
# jam -j4 -q -sCROSS_COMPILE_WINDOWS=true
# if $(CROSS_COMPILE_WINDOWS)
# {
# 	CC = x86_64-w64-mingw32-gcc ;
# 	LINK = x86_64-w64-mingw32-gcc ;
# 	AR = x86_64-w64-mingw32-ar ;
# 	SUFSHR = .dll ;
# }

# Some helpful Jam commands
# -q        : stop on failed target
# -jN       : use N cores
# -sVAR=VAL : Set VAR to VAL. Note that setting WINDOWS=false is the same as setting UNREAL=true,
#              frustratingly
# -dx       : print commands being used
# -n        : don't actually run commands

#
# Cake support
#

# See
# https://swarm.workshop.perforce.com/view/guest/perforce_software/jam/src/Jamfile.html
# https://swarm.workshop.perforce.com/projects/perforce_software-jam/view/main/src/Jambase
# http://david.freetype.org/jam/jam-language-3.html

# This basically tells Jam "if you want a object file but you
#  have a .cake file, run this rule to get an object file"
rule UserObject
{
  switch $(>)
  {
	case *.cake   : ObjectFromCakelisp $(<) : $(>) ;
	case *      : ECHO "unknown suffix on" $(>) ;
  }
}

rule ObjectFromCakelisp
{
  # $(1) = object
  # $(2) = .cake
  Depends $(1) : $(2).cpp ;
  Cakelisp $(2).cpp : $(2) ;
  # This essentially resumes the normal behavior after we've spliced in our generate
  Object $(1) : $(2).cpp ;

  # Determine the C/C++ headers this Cakelisp file should depend on
  # Note that this rule will apply to the imports too, so it
  #  must support both C/C++ includes and Cakelisp imports
  # Regex based on the HDRSCAN provided in Jambase
  HDRSCAN on $(2) =
  "[ 	]*[#(][ 	]*include[ 	]*[<\"]*([^\">]*)[\">].*$" ;

  HDRRULE on $(2) = CakelispHeaders ;

  # Get rid of the .o as well as the generated code
  Clean clean : $(1) $(2).cpp $(2).hpp ;
}

# A.cake (include "B.cake")
# Before A.cake can build, B.cake.hpp must be generated

rule CakelispHeaders
{
  # Depends $(>) : $(<) ;
  for i in $(>)
  {
	if ".cake" = $(i:S)
	{
	  # If making A.cake, and A.cake includes B.cake, A.o cannot be compiled until B.o is compiled
	  # TODO This rule is suboptimal because recompilation should only happen if B.cake.hpp changes
	  # TODO This doesn't fail jam building if the specified cake file is not going to be built. OK?
	  # Depends $(<:S=$(SUFOBJ)) : $(i:S=$(SUFOBJ)) ;

	  # Header variant (broken)
	  # This will seem like it works, but touch DepOfDep.hpp and it'll break again
	  Includes $(<) : $(i).hpp ;
	  # The header will be generated with the cpp, which is the sign generation has occurred
	  # It would be possible to run cakelisp for the hpp, but it ends up running generation twice
	  # These rules cause generation cycles once touching DepOfDeps.hpp
	  # One vs. the other changes when things are allowed to build (e.g. depending on SUFOBJ
	  # means clang must run first, which isn't actually necessary for header files)
	  Depends $(i).hpp : $(i).cpp ;
	  # Depends $(i).hpp : $(i:S=$(SUFOBJ)) ;

	  # LEFT OFF: Cpp file is rebuilt if DepOfDeps.hpp changes
	  # Is there any way I can make the system aware of the hpp, but not inherit its internal includes?
	  # Full repro:
	  # jam clean
	  # (compile "jam -dd -dc -dx")
	  # touch DepOfDeps.hpp
	  # (compile "jam -dd -dc -dx")
	  # It'll now regenerate every single time (and recompile! ;_; )

	  # How do you make the header file? You need to generate it
	  # Cakelisp $(i).cpp : $(i) ;
	  # Depends $(i).hpp : $(i:S=$(SUFOBJ)) ;

	  # Other (unsuccessful) variations
	  # Depends $(<) : $(i) ;

	  # Depends $(i:S=$(SUFOBJ)) : $(i) ;

	  # Depends $(<) : $(i).hpp ;
	  # Depends $(i).hpp : $(i) ;

	  #unnecessary rebuilds, but looks good otherwise
	  # Depends $(<) : $(i).hpp ;
	  # Depends $(i).hpp : $(i:S=$(SUFOBJ)) ;

	  # Depends $(<) : $(i) ;
	  # Depends $(i) : $(i:S=$(SUFOBJ)) ;

	  # Unnecessary rebuilds!
	  # Depends $(<) : $(i:S=$(SUFOBJ)) ;
	  # Will build the SUFOBJ!
	  # Cakelisp $(<) : $(i:S=$(SUFOBJ)) ;
	  # HdrRule $(<) : $(>) ;
	}
	else
	{
	  # Handle C/C++ scanning by delegating to the regular HdrRule
	  HdrRule $(<) : $(i) ;
	}
  }
}

rule Cakelisp
{
  # The generated cpp file depends on the cake file; if the cake changes, it must be recreated
  Depends $(1) : $(2) ;
  # Echo Making target $(1) ;
}

actions Cakelisp
{
  # echo For $(1)
  $(CAKELISP) $(2)
}